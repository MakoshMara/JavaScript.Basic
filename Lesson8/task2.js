// if (!("a" in window)) {
//     var a = 1;
// }
// alert(a);

/* Выдаст undefined. Объявление переменной (но не присвоение ей значения) сработало в самом начале скрипта,
так как сделано через var, и условие if никогда не будет выполненно, соответсвенно и переменной не присвоится значение*/


// var b = function a(x) {
//     x && a(--x);
// };
// alert(a);

/*Ничего не произойдет) Консоль браузера скажет что а не определена, так как самой переменной а не существует. Есть функция с таким названием,
ссылка на которую которая лежит в переменной b и это не является объявлением функции.*/

// function a(x) {
//     return x * 2;
// }
// var a;
// alert(a);

/* Тут объявление переменной а "поднялось" к началу выполнения, а потом под этим "названием" опеределилась функция (ссылка на нее).
Соотвественно выведется тело функции. Без var a, кстати, сработало бы точно так же.
 */

// function b(x, y, a) {
//     arguments[2] = 10;
//     alert(a);
// }
//
// b(1, 2, 3);

/* В результате будет 10. Видимо, я не понимаю каких-то нюансов,
но для меня очевидно, что в самой функции уже происходит переприсвоение значения третьему аргументу функции (29 строка)
ну и уже как бэ все равно чего там было передано.
 */

// function a() {
//     alert(this);
// }
// a.call(null);


/* Объект window. Передача null в методе call равна передаче без ничего и означает передачу глобального объекта window.
 ИМХО, пример какой-то непоказательный. просто вызов бы этой функции дал бы такой же результат.
 Вот если бы запихать функцию в объект и вызывать как метод, было бы показательней*/